name: 05 - Initial Data Backfill

# Workflow th·ªß c√¥ng ƒë·ªÉ crawl d·ªØ li·ªáu l·ªãch s·ª≠
# Ch·ªâ ch·∫°y 1 l·∫ßn khi setup l·∫ßn ƒë·∫ßu
on:
  workflow_dispatch:
    inputs:
      days:
        description: 'Number of days to backfill'
        required: true
        default: '365'
        type: string
      region:
        description: 'Region (XSMB, XSMN, or BOTH)'
        required: true
        default: 'BOTH'
        type: choice
        options:
          - BOTH
          - XSMB
          - XSMN

jobs:
  backfill:
    name: Backfill Historical Data
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Backfill XSMB Data
        if: ${{ github.event.inputs.region == 'XSMB' || github.event.inputs.region == 'BOTH' }}
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          python -c "
          from src.crawler.xsmb_crawler import XSMBCrawler
          from src.database.supabase_client import LotteryDB
          from datetime import datetime, timedelta
          import time
          
          print('üöÄ Starting XSMB backfill...')
          print('='*60)
          
          crawler = XSMBCrawler()
          db = LotteryDB()
          days = int('${{ github.event.inputs.days }}')
          
          success_count = 0
          failed_count = 0
          
          for i in range(days):
              target_date = datetime.now() - timedelta(days=i+1)
              
              print(f'\n[{i+1}/{days}] Crawling {target_date.date()}...')
              
              results = crawler.fetch_results(target_date.date())
              
              if results:
                  try:
                      db.insert_draw(results)
                      success_count += 1
                      print(f'  ‚úÖ Success! Special Prize: {results[\"special_prize\"]}')
                  except Exception as e:
                      # C√≥ th·ªÉ b·ªã duplicate - kh√¥ng sao
                      if 'duplicate' in str(e).lower():
                          print(f'  ‚ö†Ô∏è Already exists (skipping)')
                          success_count += 1
                      else:
                          failed_count += 1
                          print(f'  ‚ùå Error: {e}')
              else:
                  failed_count += 1
                  print(f'  ‚ùå Crawl failed')
              
              # Rate limiting - tr√°nh b·ªã block
              if i < days - 1:  # Kh√¥ng sleep ·ªü l·∫ßn cu·ªëi
                  print(f'  üí§ Sleeping 3s...')
                  time.sleep(3)
          
          print('\n' + '='*60)
          print(f'üìä XSMB Backfill Summary:')
          print(f'  ‚úÖ Success: {success_count}/{days}')
          print(f'  ‚ùå Failed: {failed_count}/{days}')
          print(f'  üìà Success rate: {success_count/days*100:.1f}%')
          
          # Log final status
          db.log_crawler_status({
              'crawl_date': datetime.now().date(),
              'region': 'XSMB',
              'status': 'success' if success_count > days/2 else 'partial',
              'error_message': f'Backfill: {success_count}/{days} successful',
              'records_inserted': success_count
          })
          "
      
      - name: Wait before XSMN
        if: ${{ github.event.inputs.region == 'BOTH' }}
        run: |
          echo "Waiting 10 seconds before starting XSMN backfill..."
          sleep 10
      
      - name: Backfill XSMN Data
        if: ${{ github.event.inputs.region == 'XSMN' || github.event.inputs.region == 'BOTH' }}
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          python -c "
          from src.crawler.xsmn_crawler import XSMNCrawler
          from src.database.supabase_client import LotteryDB
          from datetime import datetime, timedelta
          import time
          
          print('üöÄ Starting XSMN backfill...')
          print('='*60)
          
          crawler = XSMNCrawler()
          db = LotteryDB()
          days = int('${{ github.event.inputs.days }}')
          
          success_count = 0
          failed_count = 0
          
          for i in range(days):
              target_date = datetime.now() - timedelta(days=i+1)
              
              print(f'\n[{i+1}/{days}] Crawling {target_date.date()}...')
              
              results = crawler.fetch_results(target_date.date(), province='tp-hcm')
              
              if results:
                  try:
                      db.insert_draw(results)
                      success_count += 1
                      print(f'  ‚úÖ Success! Special Prize: {results[\"special_prize\"]}')
                  except Exception as e:
                      if 'duplicate' in str(e).lower():
                          print(f'  ‚ö†Ô∏è Already exists (skipping)')
                          success_count += 1
                      else:
                          failed_count += 1
                          print(f'  ‚ùå Error: {e}')
              else:
                  failed_count += 1
                  print(f'  ‚ùå Crawl failed')
              
              if i < days - 1:
                  print(f'  üí§ Sleeping 3s...')
                  time.sleep(3)
          
          print('\n' + '='*60)
          print(f'üìä XSMN Backfill Summary:')
          print(f'  ‚úÖ Success: {success_count}/{days}')
          print(f'  ‚ùå Failed: {failed_count}/{days}')
          print(f'  üìà Success rate: {success_count/days*100:.1f}%')
          
          db.log_crawler_status({
              'crawl_date': datetime.now().date(),
              'region': 'XSMN',
              'status': 'success' if success_count > days/2 else 'partial',
              'error_message': f'Backfill: {success_count}/{days} successful',
              'records_inserted': success_count
          })
          "
