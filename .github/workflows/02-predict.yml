name: 02 - Generate Predictions

# Ch·∫°y h√†ng ng√†y l√∫c 20:00 GMT+7 (13:00 UTC)
# Sau khi crawl xong
on:
  schedule:
    - cron: '0 13 * * *'  # 20:00 GMT+7
  workflow_dispatch:

jobs:
  predict-xsmb:
    name: Generate XSMB Prediction
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Generate Prediction
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python -c "
          import asyncio
          from src.models.frequency_analyzer import FrequencyAnalyzer
          from src.database.supabase_client import LotteryDB
          from src.bot.telegram_bot import LotteryNotifier
          from datetime import datetime, timedelta
          
          async def main():
              print('üéØ Generating XSMB prediction...')
              
              db = LotteryDB()
              try:
                  bot = LotteryNotifier()
              except Exception as e:
                  print(f'‚ö†Ô∏è Could not init bot: {e}')
                  bot = None
              
              try:
                  # L·∫•y 90 ng√†y d·ªØ li·ªáu l·ªãch s·ª≠ (XSMB kh√¥ng c·∫ßn province)
                  historical = db.get_historical_data('XSMB', days=90)
                  
                  if not historical or len(historical) < 30:
                      error_msg = f'Not enough historical data (need at least 30 days). Current: {len(historical) if historical else 0} days'
                      print(f'‚ö†Ô∏è {error_msg}')
                      if bot: await bot.send_error_alert(f'XSMB Prediction Failed: {error_msg}')
                      exit(1)
                  
                  print(f'üìä Loaded {len(historical)} historical records')
                  
                  # Train model
                  analyzer = FrequencyAnalyzer(historical)
                  prediction = analyzer.predict_next(n_digits=5)
                  
                  # L∆∞u d·ª± ƒëo√°n cho ng√†y mai
                  tomorrow = datetime.now() + timedelta(days=1)
                  
                  db.save_prediction({
                      'prediction_date': tomorrow.date(),
                      'region': 'XSMB',
                      'province': None,  # XSMB kh√¥ng c√≥ province
                      'model_version': 'frequency_v1',
                      'predicted_numbers': prediction,
                      'confidence_score': prediction['confidence']
                  })
                  
                  print(f'‚úÖ Prediction saved for {tomorrow.date()}')
                  print(f'   Predicted number: {prediction[\"predicted_number\"]}')
                  print(f'   Confidence: {prediction[\"confidence\"]*100:.0f}%')
                  print(f'   Hot numbers: {prediction[\"hot_numbers\"]}')
                  
                  # Send notification
                  if bot:
                      await bot.send_prediction({
                          'region': 'XSMB',
                          'date': tomorrow.date(),
                          'predicted_number': prediction['predicted_number'],
                          'confidence_score': prediction['confidence'],
                          'hot_numbers': prediction['hot_numbers'],
                          'model_version': 'frequency_v1'
                      })
                      print('‚úÖ Prediction sent to Telegram')
                  
              except Exception as e:
                  print(f'‚ùå Error: {e}')
                  if bot: await bot.send_error_alert(f'XSMB Prediction Error: {e}')
                  exit(1)

          if __name__ == '__main__':
              asyncio.run(main())
          "
  
  predict-xsmn:
    name: Generate XSMN Predictions (All Provinces)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Generate Predictions for All Provinces
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python -c "
          import asyncio
          from src.models.frequency_analyzer import FrequencyAnalyzer
          from src.database.supabase_client import LotteryDB
          from src.bot.telegram_bot import LotteryNotifier
          from src.crawler.xsmn_crawler import XSMNCrawler
          from datetime import datetime, timedelta
          
          async def main():
              print('üéØ Generating XSMN predictions...')
              
              db = LotteryDB()
              crawler = XSMNCrawler()
              try:
                  bot = LotteryNotifier()
              except Exception as e:
                  print(f'‚ö†Ô∏è Could not init bot: {e}')
                  bot = None
                  
              # Use Vietnam Time (UTC+7)
              vn_now = datetime.utcnow() + timedelta(hours=7)
              tomorrow = vn_now + timedelta(days=1)
              
              print(f'Current Vietnam Time: {vn_now}')
              print(f'Prediction Date: {tomorrow.date()}')
              
              # Ch·ªâ generate cho c√°c t·ªânh quay v√†o ng√†y mai
              provinces = crawler.get_provinces_for_date(tomorrow.date())
              print(f'üìç Target Provinces: {provinces}')
              print('=' * 60)
              
              success_count = 0
              failed_count = 0
              errors = []
              
              for province in provinces:
                  try:
                      print(f'\nüìç {province.upper()}...')
                      
                      # L·∫•y d·ªØ li·ªáu l·ªãch s·ª≠ cho t·ªânh n√†y
                      historical = db.get_historical_data('XSMN', days=90, province=province)
                      
                      if not historical or len(historical) < 30:
                          print(f'   ‚ö†Ô∏è Not enough data ({len(historical) if historical else 0} days)')
                          failed_count += 1
                          continue
                      
                      print(f'   üìä Loaded {len(historical)} records')
                      
                      # Train model cho t·ªânh n√†y
                      analyzer = FrequencyAnalyzer(historical)
                      prediction = analyzer.predict_next(n_digits=6)  # XSMN c√≥ 6 ch·ªØ s·ªë
                      
                      # L∆∞u d·ª± ƒëo√°n
                      db.save_prediction({
                          'prediction_date': tomorrow.date(),
                          'region': 'XSMN',
                          'province': province,
                          'model_version': 'frequency_v1',
                          'predicted_numbers': prediction,
                          'confidence_score': prediction['confidence']
                      })
                      
                      print(f'   ‚úÖ Predicted: {prediction[\"predicted_number\"]} (confidence: {prediction[\"confidence\"]*100:.0f}%)')
                      success_count += 1
                      
                      # Send notification (immediate)
                      if bot:
                          await bot.send_prediction({
                              'region': 'XSMN',
                              'province': province,
                              'date': tomorrow.date(),
                              'predicted_number': prediction['predicted_number'],
                              'confidence_score': prediction['confidence'],
                              'model_version': 'frequency_v1'
                          })
                          print(f'   ‚úÖ Notification sent for {province}')
                      
                  except Exception as e:
                      print(f'   ‚ùå Error: {e}')
                      failed_count += 1
                      errors.append(f'{province}: {str(e)}')
              
              print('\n' + '=' * 60)
              print(f'üìä Summary:')
              print(f'   ‚úÖ Success: {success_count}/{len(provinces)}')
              print(f'   ‚ùå Failed: {failed_count}/{len(provinces)}')
              print('=' * 60)
              
              if success_count == 0:
                  error_msg = 'No predictions generated!'
                  print(f'‚ùå {error_msg}')
                  if bot: await bot.send_error_alert(f'XSMN Prediction Failed: {error_msg}')
                  exit(1)
              
              if failed_count > 0:
                  # Optional: Alert on partial failures?
                  pass

          if __name__ == '__main__':
              asyncio.run(main())
          "
